This kata was troubleshooting a failed test that I initially thought was related to archetype, but was not. Instead, it was related to the behavior of chai's deepEqual (and most other deepEqual implementations). They generally check if a property is an object or primitive. If primitive, then == is used (or === if using deepStrictEqual) and otherwise recurse into the object. In our case the two objects had id properties that were both logically equal (string representation of the ids matches, and .equals method on the objects also returns true), but deepEquals reported a mismatch due to some internals of the two objects that we don't want to have to care about. Therefore we determined that it would be preferable to use a deepEqual implementation that uses the .equal implementation of a give property if present. We couldn't find one, so we wrote one and it can be found in deepDotEquals.js.
